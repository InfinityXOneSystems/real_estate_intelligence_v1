name: Infinity Prime - Approver

on:
  pull_request_target:
    types: [labeled, synchronize, opened, reopened]

permissions:
  contents: read
  issues: write
  pull-requests: write
  checks: read

jobs:
  approve-if-safe:
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate PR for auto-approval
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) return;
            if (pr.head.repo.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
              console.log('External PR; skipping');
              return;
            }
            // check labels
            const labels = pr.labels.map(l => l.name);
            if (!labels.includes('infinity-prime')) {
              console.log('Not an Infinity Prime PR; skipping');
              return;
            }
            // get files and compute highest tier (reuse logic)
            const files = await github.paginate(github.rest.pulls.listFiles, { owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number });
            const paths = files.map(f => f.filename);
            let prot = {};
            try {
              const res = await github.rest.repos.getContent({ owner: context.repo.owner, repo: context.repo.repo, path: 'docs/system/PROTECTED_PATHS.yaml', ref: pr.base.ref });
              const content = Buffer.from(res.data.content, 'base64').toString();
              const lines = content.split('\n').map(l => l.trim());
              let current = null;
              for (const l of lines) {
                const m = l.match(/^Tier(\d):/);
                if (m) current = 'Tier' + m[1];
                const m2 = l.match(/^-\s+"(.+)"/);
                if (m2 && current) prot[m2[1]] = current;
              }
            } catch (e) {
              console.log('Could not load PROTECTED_PATHS.yaml:', e.message);
            }
            let highest = 1;
            for (const f of paths) {
              for (const pattern in prot) {
                if (pattern.endsWith('/**')) {
                  const prefix = pattern.replace('/**','');
                  if (f.startsWith(prefix)) highest = Math.max(highest, parseInt(prot[pattern].replace('Tier','')) || 1);
                } else if (f === pattern) {
                  highest = Math.max(highest, parseInt(prot[pattern].replace('Tier','')) || 1);
                }
              }
            }
            console.log('Highest tier:', highest);
            // If tier < 4, can be auto-approved if checks are green and risk gate SAFE
            if (highest < 4) {
              // check combined status for PR head
              const status = await github.rest.repos.getCombinedStatusForRef({ owner: context.repo.owner, repo: context.repo.repo, ref: pr.head.sha });
              console.log('Combined status state:', status.data.state);
              if (status.data.state !== 'success') {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: `Infinity Prime: waiting for required checks to pass (current: ${status.data.state}).` });
                return;
              }
              // simple risk check placeholder: if no files in docs/system/BLOCKED_TIER4_CHANGES.md changed then SAFE
              const blocked = paths.some(p => p.startsWith('docs/system/') && p.includes('BLOCKED_TIER4_CHANGES'));
              if (blocked) {
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Infinity Prime: PR touches blocked evidence; manual review required.' });
                return;
              }
              // attempt to approve
              try {
                await github.rest.pulls.createReview({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number, event: 'APPROVE', body: 'Infinity Prime auto-approval (SAFE).' });
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Infinity Prime: auto-approved and attempting to enable auto-merge.' });
                // try enable auto-merge
                try {
                  await github.rest.pulls.enableAutomerge({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number, merge_method: 'squash' });
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Infinity Prime: auto-merge enabled.' });
                } catch (e) {
                  console.log('Could not enable auto-merge:', e.message);
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Infinity Prime: failed to enable auto-merge; please enable repository automerge or provide the approver token.' });
                }
              } catch (e) {
                console.log('Approval failed:', e.message);
                // create blocked-permissions issue
                await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title: `blocked-permissions: Infinity Prime cannot approve PR #${pr.number}`, body: `The Infinity Prime approver workflow attempted to approve PR #${pr.number} but lacked permission. Please ensure the workflow has permission to approve or set the INFINITY_PRIME_APPROVER_TOKEN with 'repo' and 'pull_request' scopes.` });
              }
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Infinity Prime: Tier-4 change detected; requires manual approval per policy.' });
            }
